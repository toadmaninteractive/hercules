// Author: Igor compiler
// Compiler version: igorc 2.1.3
// DO NOT EDIT THIS FILE - it is machine generated

using System;
using System.Collections.Generic;
using System.IO;

using IgorSerializer = Igor.Serialization.IgorSerializer;

namespace Unreal
{
    public struct FGuid
    {
        public uint A { get; set; }

        public uint B { get; set; }

        public uint C { get; set; }

        public uint D { get; set; }
    }

    public sealed class FCustomVersion
    {
        public int Key { get; set; }

        public FGuid Version { get; set; }
    }

    public sealed class FGenerationInfo
    {
        /// <summary>
        /// Number of exports in the linker's ExportMap for this generation.
        /// </summary>
        public int ExportCount { get; set; }

        /// <summary>
        /// Number of names in the linker's NameMap for this generation.
        /// </summary>
        public int NameCount { get; set; }
    }

    public sealed class FEngineVersion
    {
        /// <summary>
        /// Major version number.
        /// </summary>
        public ushort Major { get; set; } = 0;

        /// <summary>
        /// Minor version number.
        /// </summary>
        public ushort Minor { get; set; } = 0;

        /// <summary>
        /// Patch version number.
        /// </summary>
        public ushort Patch { get; set; } = 0;

        /// <summary>
        /// Changelist number. This is used to arbitrate when Major/Minor/Patch version numbers match. Use GetChangelist() instead of using this member directly.
        /// </summary>
        public uint Changelist { get; set; } = 0;

        /// <summary>
        /// Branch name.
        /// </summary>
        public string Branch { get; set; } = "";
    }

    /// <summary>
    /// Information about a compressed chunk in a file.
    /// </summary>
    public sealed class FCompressedChunk
    {
        /// <summary>
        /// Original offset in uncompressed file.
        /// </summary>
        public int UncompressedOffset { get; set; }

        /// <summary>
        /// Uncompressed size in bytes.
        /// </summary>
        public int UncompressedSize { get; set; }

        /// <summary>
        /// Offset in compressed file.
        /// </summary>
        public int CompressedOffset { get; set; }

        /// <summary>
        /// Compressed size in bytes.
        /// </summary>
        public int CompressedSize { get; set; }
    }

    /// <summary>
    /// A "table of contents" for an Unreal package file. Stored at the top of the file.
    /// </summary>
    public sealed class FPackageFileSummary
    {
        /// <summary>
        /// Magic tag compared against PACKAGE_FILE_TAG to ensure that package is an Unreal package.
        /// </summary>
        public uint Tag { get; set; }

        /// <summary>
        /// The package file version number when this package was saved.
        ///
        /// Lower 16 bits stores the UE3 engine version
        /// Upper 16 bits stores the UE4/licensee version
        /// For newer packages this is -7
        /// -2 indicates presence of enum-based custom versions
        /// -3 indicates guid-based custom versions
        /// -4 indicates removal of the UE3 version. Packages saved with this ID cannot be loaded in older engine versions
        /// -5 indicates the replacement of writing out the "UE3 version" so older versions of engine can gracefully fail to open newer packages
        /// -6 indicates optimizations to how custom versions are being serialized
        /// -7 indicates the texture allocation info has been removed from the summary
        /// </summary>
        public int LegacyFileVersion { get; set; }

        public int LegacyUe3Version { get; set; }

        /// <summary>
        /// UE4 file version
        /// </summary>
        public int FileVersionUe4 { get; set; }

        /// <summary>
        /// UE5 file version
        /// </summary>
        public int FileVersionUe5 { get; set; }

        /// <summary>
        /// Licensee file version
        /// </summary>
        public int FileVersionLicenseeUe4 { get; set; }

        /// <summary>
        /// Custom version numbers. Keyed off a unique tag for each custom component.
        /// </summary>
        public IReadOnlyList<FCustomVersion> CustomVersions { get; set; } = System.Array.Empty<FCustomVersion>();

        /// <summary>
        /// Total size of all information that needs to be read in to create a FLinkerLoad.
        /// This includes the package file summary, name table and import & export maps.
        /// </summary>
        public int TotalHeaderSize { get; set; }

        /// <summary>
        /// The Generic Browser folder name that this package lives in
        /// </summary>
        public string FolderName { get; set; } = "";

        /// <summary>
        /// The flags for the package
        /// </summary>
        public uint PackageFlags { get; set; }

        /// <summary>
        /// Number of names used in this package
        /// </summary>
        public int NameCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the name data
        /// </summary>
        public int NameOffset { get; set; }

        /// <summary>
        /// Number of soft object paths references contained in this package
        /// @note: the soft object path lists slightly duplicate information found in the SoftPackageReferences list
        /// </summary>
        public int SoftObjectPathsCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the soft object paths reference list
        /// </summary>
        public int SoftObjectPathsOffset { get; set; }

        /// <summary>
        /// Localization ID of this package
        /// This is copy of the version stored in the package meta-data.
        /// It exists here so we can query it without having to load the whole package
        /// </summary>
        public string LocalizationId { get; set; } = "";

        /// <summary>
        /// Number of gatherable text data items in this package
        /// </summary>
        public int GatherableTextDataCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the gatherable text data items
        /// </summary>
        public int GatherableTextDataOffset { get; set; }

        /// <summary>
        /// Number of exports contained in this package
        /// </summary>
        public int ExportCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the ExportMap data
        /// </summary>
        public int ExportOffset { get; set; }

        /// <summary>
        /// Number of imports contained in this package
        /// </summary>
        public int ImportCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the ImportMap data
        /// </summary>
        public int ImportOffset { get; set; }

        /// <summary>
        /// Location into the file on disk for the DependsMap data
        /// </summary>
        public int DependsOffset { get; set; }

        /// <summary>
        /// Number of soft package references contained in this package
        /// </summary>
        public int SoftPackageReferencesCount { get; set; }

        /// <summary>
        /// Location into the file on disk for the soft package reference list
        /// </summary>
        public int SoftPackageReferencesOffset { get; set; }

        /// <summary>
        /// Location into the file on disk for the SearchableNamesMap data
        /// </summary>
        public int SearchableNamesOffset { get; set; }

        /// <summary>
        /// Thumbnail table offset
        /// </summary>
        public int ThumbnailTableOffset { get; set; }
    }

    public sealed class FNameEntrySerialized
    {
        public string Name { get; set; } = "";

        public ushort NonCasePreservingHash { get; set; }

        public ushort CasePreservingHash { get; set; }
    }

    public struct FPackageIndex
    {
        public int Index { get; set; }
    }

    public struct FName
    {
        public int NameIndex { get; set; }

        public int Number { get; set; }
    }

    public sealed class FObjectImport
    {
        /// <summary>
        /// The name of the package that contains the class of the UObject represented by this resource.
        /// </summary>
        public FName ClassPackage { get; set; }

        /// <summary>
        /// The name of the class for the UObject represented by this resource.
        /// </summary>
        public FName ClassName { get; set; }

        /// <summary>
        /// Location of the resource for this resource's Outer. Values of 0 indicate that this resource
        /// represents a top-level UPackage object (the linker's LinkerRoot).
        /// Serialized
        /// </summary>
        public FPackageIndex OuterIndex { get; set; }

        /// <summary>
        /// The name of the UObject represented by this resource.
        /// </summary>
        public FName ObjectName { get; set; }
    }

    /// <summary>
    /// UObject resource type for objects that are contained within this package and can
    /// be referenced by other packages.
    /// </summary>
    public sealed class FObjectExport
    {
        /// <summary>
        /// Location of the resource for this export's class (if non-zero). A value of zero
        /// indicates that this export represents a UClass object; there is no resource for
        /// this export's class object
        /// </summary>
        public FPackageIndex ClassIndex { get; set; }

        /// <summary>
        /// Location of the resource for this export's SuperField (parent). Only valid if
        /// this export represents a UStruct object. A value of zero indicates that the object
        /// represented by this export isn't a UStruct-derived object.
        /// </summary>
        public FPackageIndex SuperIndex { get; set; }

        /// <summary>
        /// Location of the resource for this export's template/archetypes. Only used
        /// in the new cooked loader. A value of zero indicates that the value of GetArchetype
        /// was zero at cook time, which is more or less impossible and checked.
        /// </summary>
        public FPackageIndex TemplateIndex { get; set; }

        public FPackageIndex OuterIndex { get; set; }

        public FName ObjectName { get; set; }

        /// <summary>
        /// The object flags for the UObject represented by this resource. Only flags that
        /// match the RF_Load combination mask will be loaded from disk and applied to the UObject.
        /// </summary>
        public uint ObjectFlags { get; set; }

        /// <summary>
        /// The number of bytes to serialize when saving/loading this export's UObject.
        /// </summary>
        public long SerialSize { get; set; }

        /// <summary>
        /// The location (into the FLinker's underlying file reader archive) of the beginning of the
        /// data for this export's UObject. Used for verification only.
        /// </summary>
        public long SerialOffset { get; set; }

        /// <summary>
        /// Whether the export was forced into the export table via OBJECTMARK_ForceTagExp.
        /// </summary>
        public int BForcedExport { get; set; }

        /// <summary>
        /// Whether the export should be loaded on clients
        /// </summary>
        public int BNotForClient { get; set; }

        /// <summary>
        /// Whether the export should be loaded on servers
        /// </summary>
        public int BNotForServer { get; set; }

        /// <summary>
        /// If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp)
        /// this is the GUID for the original package file
        /// </summary>
        public FGuid PackageGuid { get; set; }

        /// <summary>
        /// If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp)
        /// this is the package flags for the original package file
        /// </summary>
        public uint PackageFlags { get; set; }

        /// <summary>
        /// Whether the export should be always loaded in editor game
        /// False means that the object is
        /// True doesn't means, that the object won't be loaded.
        /// </summary>
        public int BNotAlwaysLoadedForEditorGame { get; set; }

        public int BIsAsset { get; set; }

        /// <summary>
        /// The export table must serialize as a fixed size, this is use to index into a long list, which is later loaded into the array. -1 means dependencies are not
        /// present
        /// These are contiguous blocks, so CreateBeforeSerializationDependencies starts at FirstExportDependency + SerializationBeforeSerializationDependencies
        /// </summary>
        public int FirstExportDependency { get; set; }

        public int SerializationBeforeSerializationDependencies { get; set; }

        public int CreateBeforeSerializationDependencies { get; set; }

        public int SerializationBeforeCreateDependencies { get; set; }

        public int CreateBeforeCreateDependencies { get; set; }
    }

    public sealed class FThumbnailAssetData
    {
        public string AssetClassName { get; set; } = "";

        public string ObjectPathWithoutPackageName { get; set; } = "";

        public int FileOffset { get; set; }
    }

    public sealed class FObjectThumbnail
    {
        public int ImageWidth { get; set; }

        public int ImageHeight { get; set; }

        public byte[] CompressedImageData { get; set; }
    }

    public sealed class FGuidBinarySerializer : Igor.Serialization.IBinarySerializer<FGuid>
    {
        public static readonly FGuidBinarySerializer Instance = new FGuidBinarySerializer();

        public void Serialize(BinaryWriter writer, FGuid value)
        {
            IgorSerializer.UInt.Serialize(writer, value.A);
            IgorSerializer.UInt.Serialize(writer, value.B);
            IgorSerializer.UInt.Serialize(writer, value.C);
            IgorSerializer.UInt.Serialize(writer, value.D);
        }

        public FGuid Deserialize(BinaryReader reader)
        {
            var result = new FGuid();
            Deserialize(reader, ref result);
            return result;
        }

        public void Deserialize(BinaryReader reader, ref FGuid value)
        {
            value.A = IgorSerializer.UInt.Deserialize(reader);
            value.B = IgorSerializer.UInt.Deserialize(reader);
            value.C = IgorSerializer.UInt.Deserialize(reader);
            value.D = IgorSerializer.UInt.Deserialize(reader);
        }
    }

    public sealed class FCustomVersionBinarySerializer : Igor.Serialization.IBinarySerializer<FCustomVersion>
    {
        public static readonly FCustomVersionBinarySerializer Instance = new FCustomVersionBinarySerializer();

        public void Serialize(BinaryWriter writer, FCustomVersion value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            IgorSerializer.Int.Serialize(writer, value.Key);
            FGuidBinarySerializer.Instance.Serialize(writer, value.Version);
        }

        public FCustomVersion Deserialize(BinaryReader reader)
        {
            var result = new FCustomVersion();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FCustomVersion value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.Key = IgorSerializer.Int.Deserialize(reader);
            value.Version = FGuidBinarySerializer.Instance.Deserialize(reader);
        }
    }

    public sealed class FGenerationInfoBinarySerializer : Igor.Serialization.IBinarySerializer<FGenerationInfo>
    {
        public static readonly FGenerationInfoBinarySerializer Instance = new FGenerationInfoBinarySerializer();

        public void Serialize(BinaryWriter writer, FGenerationInfo value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            IgorSerializer.Int.Serialize(writer, value.ExportCount);
            IgorSerializer.Int.Serialize(writer, value.NameCount);
        }

        public FGenerationInfo Deserialize(BinaryReader reader)
        {
            var result = new FGenerationInfo();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FGenerationInfo value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.ExportCount = IgorSerializer.Int.Deserialize(reader);
            value.NameCount = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FEngineVersionBinarySerializer : Igor.Serialization.IBinarySerializer<FEngineVersion>
    {
        public static readonly FEngineVersionBinarySerializer Instance = new FEngineVersionBinarySerializer();

        public void Serialize(BinaryWriter writer, FEngineVersion value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Branch == null)
                throw new System.ArgumentException("Required property Branch is null", nameof(value));
            IgorSerializer.UShort.Serialize(writer, value.Major);
            IgorSerializer.UShort.Serialize(writer, value.Minor);
            IgorSerializer.UShort.Serialize(writer, value.Patch);
            IgorSerializer.UInt.Serialize(writer, value.Changelist);
            UnrealTypes.FString.Serialize(writer, value.Branch);
        }

        public FEngineVersion Deserialize(BinaryReader reader)
        {
            var result = new FEngineVersion();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FEngineVersion value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.Major = IgorSerializer.UShort.Deserialize(reader);
            value.Minor = IgorSerializer.UShort.Deserialize(reader);
            value.Patch = IgorSerializer.UShort.Deserialize(reader);
            value.Changelist = IgorSerializer.UInt.Deserialize(reader);
            value.Branch = UnrealTypes.FString.Deserialize(reader);
        }
    }

    public sealed class FCompressedChunkBinarySerializer : Igor.Serialization.IBinarySerializer<FCompressedChunk>
    {
        public static readonly FCompressedChunkBinarySerializer Instance = new FCompressedChunkBinarySerializer();

        public void Serialize(BinaryWriter writer, FCompressedChunk value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            IgorSerializer.Int.Serialize(writer, value.UncompressedOffset);
            IgorSerializer.Int.Serialize(writer, value.UncompressedSize);
            IgorSerializer.Int.Serialize(writer, value.CompressedOffset);
            IgorSerializer.Int.Serialize(writer, value.CompressedSize);
        }

        public FCompressedChunk Deserialize(BinaryReader reader)
        {
            var result = new FCompressedChunk();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FCompressedChunk value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.UncompressedOffset = IgorSerializer.Int.Deserialize(reader);
            value.UncompressedSize = IgorSerializer.Int.Deserialize(reader);
            value.CompressedOffset = IgorSerializer.Int.Deserialize(reader);
            value.CompressedSize = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FPackageFileSummaryBinarySerializer : Igor.Serialization.IBinarySerializer<FPackageFileSummary>
    {
        public static readonly FPackageFileSummaryBinarySerializer Instance = new FPackageFileSummaryBinarySerializer();

        public void Serialize(BinaryWriter writer, FPackageFileSummary value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.CustomVersions == null)
                throw new System.ArgumentException("Required property CustomVersions is null", nameof(value));

            if (value.FolderName == null)
                throw new System.ArgumentException("Required property FolderName is null", nameof(value));

            if (value.LocalizationId == null)
                throw new System.ArgumentException("Required property LocalizationId is null", nameof(value));

            IgorSerializer.UInt.Serialize(writer, value.Tag);
            IgorSerializer.Int.Serialize(writer, value.LegacyFileVersion);
            IgorSerializer.Int.Serialize(writer, value.LegacyUe3Version);
            IgorSerializer.Int.Serialize(writer, value.FileVersionUe4);
            if (value.LegacyFileVersion <= -8)
                IgorSerializer.Int.Serialize(writer, value.FileVersionUe5);
            IgorSerializer.Int.Serialize(writer, value.FileVersionLicenseeUe4);
            UnrealTypes.TArray<FCustomVersion>(FCustomVersionBinarySerializer.Instance).Serialize(writer, value.CustomVersions);
            IgorSerializer.Int.Serialize(writer, value.TotalHeaderSize);
            UnrealTypes.FString.Serialize(writer, value.FolderName);
            IgorSerializer.UInt.Serialize(writer, value.PackageFlags);
            IgorSerializer.Int.Serialize(writer, value.NameCount);
            IgorSerializer.Int.Serialize(writer, value.NameOffset);
            UnrealTypes.FString.Serialize(writer, value.LocalizationId);
            IgorSerializer.Int.Serialize(writer, value.GatherableTextDataCount);
            IgorSerializer.Int.Serialize(writer, value.GatherableTextDataOffset);
            IgorSerializer.Int.Serialize(writer, value.ExportCount);
            IgorSerializer.Int.Serialize(writer, value.ExportOffset);
            IgorSerializer.Int.Serialize(writer, value.ImportCount);
            IgorSerializer.Int.Serialize(writer, value.ImportOffset);
            IgorSerializer.Int.Serialize(writer, value.DependsOffset);
            IgorSerializer.Int.Serialize(writer, value.SoftPackageReferencesCount);
            IgorSerializer.Int.Serialize(writer, value.SoftPackageReferencesOffset);
            IgorSerializer.Int.Serialize(writer, value.SearchableNamesOffset);
            IgorSerializer.Int.Serialize(writer, value.ThumbnailTableOffset);
        }

        public FPackageFileSummary Deserialize(BinaryReader reader)
        {
            var result = new FPackageFileSummary();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FPackageFileSummary value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.Tag = IgorSerializer.UInt.Deserialize(reader);
            value.LegacyFileVersion = IgorSerializer.Int.Deserialize(reader);
            value.LegacyUe3Version = IgorSerializer.Int.Deserialize(reader);
            value.FileVersionUe4 = IgorSerializer.Int.Deserialize(reader);
            if (value.LegacyFileVersion <= -8)
                value.FileVersionUe5 = IgorSerializer.Int.Deserialize(reader);
            value.FileVersionLicenseeUe4 = IgorSerializer.Int.Deserialize(reader);
            value.CustomVersions = UnrealTypes.TArray<FCustomVersion>(FCustomVersionBinarySerializer.Instance).Deserialize(reader);
            value.TotalHeaderSize = IgorSerializer.Int.Deserialize(reader);
            value.FolderName = UnrealTypes.FString.Deserialize(reader);
            value.PackageFlags = IgorSerializer.UInt.Deserialize(reader);
            value.NameCount = IgorSerializer.Int.Deserialize(reader);
            value.NameOffset = IgorSerializer.Int.Deserialize(reader);
            if (value.FileVersionUe5 >= 1008)
            {
                value.SoftObjectPathsCount = IgorSerializer.Int.Deserialize(reader);
                value.SoftObjectPathsOffset = IgorSerializer.Int.Deserialize(reader);
            }

            if (value.FileVersionUe4 >= 516)
            {
                value.LocalizationId = UnrealTypes.FString.Deserialize(reader);
            }

            if (value.FileVersionUe4 >= 459)
            {
                value.GatherableTextDataCount = IgorSerializer.Int.Deserialize(reader);
                value.GatherableTextDataOffset = IgorSerializer.Int.Deserialize(reader);
            }

            value.ExportCount = IgorSerializer.Int.Deserialize(reader);
            value.ExportOffset = IgorSerializer.Int.Deserialize(reader);
            value.ImportCount = IgorSerializer.Int.Deserialize(reader);
            value.ImportOffset = IgorSerializer.Int.Deserialize(reader);
            value.DependsOffset = IgorSerializer.Int.Deserialize(reader);

            if (value.FileVersionUe4 >= 384)
            {
                value.SoftPackageReferencesCount = IgorSerializer.Int.Deserialize(reader);
                value.SoftPackageReferencesOffset = IgorSerializer.Int.Deserialize(reader);
            }

            if (value.FileVersionUe4 >= 518)
            {
                value.SearchableNamesOffset = IgorSerializer.Int.Deserialize(reader);
            }

            value.ThumbnailTableOffset = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FNameEntrySerializedBinarySerializer : Igor.Serialization.IBinarySerializer<FNameEntrySerialized>
    {
        public static readonly FNameEntrySerializedBinarySerializer Instance = new FNameEntrySerializedBinarySerializer();

        public void Serialize(BinaryWriter writer, FNameEntrySerialized value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            UnrealTypes.FString.Serialize(writer, value.Name);
            IgorSerializer.UShort.Serialize(writer, value.NonCasePreservingHash);
            IgorSerializer.UShort.Serialize(writer, value.CasePreservingHash);
        }

        public FNameEntrySerialized Deserialize(BinaryReader reader)
        {
            var result = new FNameEntrySerialized();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FNameEntrySerialized value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.Name = UnrealTypes.FString.Deserialize(reader);
            value.NonCasePreservingHash = IgorSerializer.UShort.Deserialize(reader);
            value.CasePreservingHash = IgorSerializer.UShort.Deserialize(reader);
        }
    }

    public sealed class FPackageIndexBinarySerializer : Igor.Serialization.IBinarySerializer<FPackageIndex>
    {
        public static readonly FPackageIndexBinarySerializer Instance = new FPackageIndexBinarySerializer();

        public void Serialize(BinaryWriter writer, FPackageIndex value)
        {
            IgorSerializer.Int.Serialize(writer, value.Index);
        }

        public FPackageIndex Deserialize(BinaryReader reader)
        {
            var result = new FPackageIndex();
            Deserialize(reader, ref result);
            return result;
        }

        public void Deserialize(BinaryReader reader, ref FPackageIndex value)
        {
            value.Index = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FNameBinarySerializer : Igor.Serialization.IBinarySerializer<FName>
    {
        public static readonly FNameBinarySerializer Instance = new FNameBinarySerializer();

        public void Serialize(BinaryWriter writer, FName value)
        {
            IgorSerializer.Int.Serialize(writer, value.NameIndex);
            IgorSerializer.Int.Serialize(writer, value.Number);
        }

        public FName Deserialize(BinaryReader reader)
        {
            var result = new FName();
            Deserialize(reader, ref result);
            return result;
        }

        public void Deserialize(BinaryReader reader, ref FName value)
        {
            value.NameIndex = IgorSerializer.Int.Deserialize(reader);
            value.Number = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FObjectImportBinarySerializer : Igor.Serialization.IBinarySerializer<FObjectImport>
    {
        public static readonly FObjectImportBinarySerializer Instance = new FObjectImportBinarySerializer();

        public void Serialize(BinaryWriter writer, FObjectImport value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            FNameBinarySerializer.Instance.Serialize(writer, value.ClassPackage);
            FNameBinarySerializer.Instance.Serialize(writer, value.ClassName);
            FPackageIndexBinarySerializer.Instance.Serialize(writer, value.OuterIndex);
            FNameBinarySerializer.Instance.Serialize(writer, value.ObjectName);
        }

        public FObjectImport Deserialize(BinaryReader reader)
        {
            var result = new FObjectImport();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FObjectImport value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.ClassPackage = FNameBinarySerializer.Instance.Deserialize(reader);
            value.ClassName = FNameBinarySerializer.Instance.Deserialize(reader);
            value.OuterIndex = FPackageIndexBinarySerializer.Instance.Deserialize(reader);
            value.ObjectName = FNameBinarySerializer.Instance.Deserialize(reader);
        }
    }

    public sealed class FObjectExportBinarySerializer : Igor.Serialization.IBinarySerializer<FObjectExport>
    {
        public static readonly FObjectExportBinarySerializer Instance = new FObjectExportBinarySerializer();

        public void Serialize(BinaryWriter writer, FObjectExport value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            FPackageIndexBinarySerializer.Instance.Serialize(writer, value.ClassIndex);
            FPackageIndexBinarySerializer.Instance.Serialize(writer, value.SuperIndex);
            FPackageIndexBinarySerializer.Instance.Serialize(writer, value.TemplateIndex);
            FPackageIndexBinarySerializer.Instance.Serialize(writer, value.OuterIndex);
            FNameBinarySerializer.Instance.Serialize(writer, value.ObjectName);
            IgorSerializer.UInt.Serialize(writer, value.ObjectFlags);
            IgorSerializer.Long.Serialize(writer, value.SerialSize);
            IgorSerializer.Long.Serialize(writer, value.SerialOffset);
            IgorSerializer.Int.Serialize(writer, value.BForcedExport);
            IgorSerializer.Int.Serialize(writer, value.BNotForClient);
            IgorSerializer.Int.Serialize(writer, value.BNotForServer);
            FGuidBinarySerializer.Instance.Serialize(writer, value.PackageGuid);
            IgorSerializer.UInt.Serialize(writer, value.PackageFlags);
            IgorSerializer.Int.Serialize(writer, value.BNotAlwaysLoadedForEditorGame);
            IgorSerializer.Int.Serialize(writer, value.BIsAsset);
            IgorSerializer.Int.Serialize(writer, value.FirstExportDependency);
            IgorSerializer.Int.Serialize(writer, value.SerializationBeforeSerializationDependencies);
            IgorSerializer.Int.Serialize(writer, value.CreateBeforeSerializationDependencies);
            IgorSerializer.Int.Serialize(writer, value.SerializationBeforeCreateDependencies);
            IgorSerializer.Int.Serialize(writer, value.CreateBeforeCreateDependencies);
        }

        public FObjectExport Deserialize(BinaryReader reader)
        {
            var result = new FObjectExport();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FObjectExport value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.ClassIndex = FPackageIndexBinarySerializer.Instance.Deserialize(reader);
            value.SuperIndex = FPackageIndexBinarySerializer.Instance.Deserialize(reader);
            value.TemplateIndex = FPackageIndexBinarySerializer.Instance.Deserialize(reader);
            value.OuterIndex = FPackageIndexBinarySerializer.Instance.Deserialize(reader);
            value.ObjectName = FNameBinarySerializer.Instance.Deserialize(reader);
            value.ObjectFlags = IgorSerializer.UInt.Deserialize(reader);
            value.SerialSize = IgorSerializer.Long.Deserialize(reader);
            value.SerialOffset = IgorSerializer.Long.Deserialize(reader);
            value.BForcedExport = IgorSerializer.Int.Deserialize(reader);
            value.BNotForClient = IgorSerializer.Int.Deserialize(reader);
            value.BNotForServer = IgorSerializer.Int.Deserialize(reader);
            value.PackageGuid = FGuidBinarySerializer.Instance.Deserialize(reader);
            value.PackageFlags = IgorSerializer.UInt.Deserialize(reader);
            value.BNotAlwaysLoadedForEditorGame = IgorSerializer.Int.Deserialize(reader);
            value.BIsAsset = IgorSerializer.Int.Deserialize(reader);
            value.FirstExportDependency = IgorSerializer.Int.Deserialize(reader);
            value.SerializationBeforeSerializationDependencies = IgorSerializer.Int.Deserialize(reader);
            value.CreateBeforeSerializationDependencies = IgorSerializer.Int.Deserialize(reader);
            value.SerializationBeforeCreateDependencies = IgorSerializer.Int.Deserialize(reader);
            value.CreateBeforeCreateDependencies = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FThumbnailAssetDataBinarySerializer : Igor.Serialization.IBinarySerializer<FThumbnailAssetData>
    {
        public static readonly FThumbnailAssetDataBinarySerializer Instance = new FThumbnailAssetDataBinarySerializer();

        public void Serialize(BinaryWriter writer, FThumbnailAssetData value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            if (value.AssetClassName == null)
                throw new System.ArgumentException("Required property AssetClassName is null", nameof(value));
            if (value.ObjectPathWithoutPackageName == null)
                throw new System.ArgumentException("Required property ObjectPathWithoutPackageName is null", nameof(value));

            UnrealTypes.FString.Serialize(writer, value.AssetClassName);
            UnrealTypes.FString.Serialize(writer, value.ObjectPathWithoutPackageName);
            IgorSerializer.Int.Serialize(writer, value.FileOffset);
        }

        public FThumbnailAssetData Deserialize(BinaryReader reader)
        {
            var result = new FThumbnailAssetData();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FThumbnailAssetData value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.AssetClassName = UnrealTypes.FString.Deserialize(reader);
            value.ObjectPathWithoutPackageName = UnrealTypes.FString.Deserialize(reader);
            value.FileOffset = IgorSerializer.Int.Deserialize(reader);
        }
    }

    public sealed class FObjectThumbnailBinarySerializer : Igor.Serialization.IBinarySerializer<FObjectThumbnail>
    {
        public static readonly FObjectThumbnailBinarySerializer Instance = new FObjectThumbnailBinarySerializer();

        public void Serialize(BinaryWriter writer, FObjectThumbnail value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.CompressedImageData == null)
                throw new System.ArgumentException("Required property CompressedImageData is null", nameof(value));
            IgorSerializer.Int.Serialize(writer, value.ImageWidth);
            IgorSerializer.Int.Serialize(writer, value.ImageHeight);
            UnrealTypes.Binary.Serialize(writer, value.CompressedImageData);
        }

        public FObjectThumbnail Deserialize(BinaryReader reader)
        {
            var result = new FObjectThumbnail();
            Deserialize(reader, result);
            return result;
        }

        public void Deserialize(BinaryReader reader, FObjectThumbnail value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            value.ImageWidth = IgorSerializer.Int.Deserialize(reader);
            value.ImageHeight = IgorSerializer.Int.Deserialize(reader);
            value.CompressedImageData = UnrealTypes.Binary.Deserialize(reader);
        }
    }
}
