// Author: Igor compiler
// Compiler version: igorc 2.1.3
// DO NOT EDIT THIS FILE - it is machine generated

using System.Collections.Generic;

using JsonSerializer = Json.Serialization.JsonSerializer;

namespace Igor.Schema
{
    public enum DescriptorKind
    {
        Bool = 1,
        Int = 2,
        Float = 3,
        String = 4,
        Binary = 5,
        List = 6,
        Dict = 7,
        Enum = 8,
        Record = 9,
        Union = 10,
        Key = 11,
        Localized = 12,
        Datetime = 13,
        Json = 14,
        Custom = 15,
        GenericInstance = 16,
        GenericArgument = 17,
    }

    public enum IntTypeName
    {
        Int8 = 1,
        Uint8 = 2,
        Int16 = 3,
        Uint16 = 4,
        Int32 = 5,
        Uint32 = 6,
        Int64 = 7,
        Uint64 = 8,
    }

    public enum FloatTypeName
    {
        Float32 = 1,
        Float64 = 2,
    }

    public enum CustomTypeKind
    {
        Record = 1,
        Variant = 2,
        Enum = 3,
        Union = 4,
    }

    public abstract class Descriptor
    {
        public abstract DescriptorKind Kind { get; }

        public bool Optional { get; }

        public string? Help { get; }

        public string? EditorKey { get; }

        public IReadOnlyDictionary<string, Json.ImmutableJson>? Meta { get; }

        protected Descriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
        {
            this.Optional = optional;
            this.Help = help;
            this.EditorKey = editorKey;
            this.Meta = meta;
        }
    }

    public sealed class BoolDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Bool;

        public bool? Default { get; }

        public BoolDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null, bool? @default = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
        }
    }

    public sealed class IntDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Int;

        public int? Default { get; }

        public int? Min { get; }

        public int? Max { get; }

        public IntTypeName? Type { get; }

        public IntDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null, int? @default = null, int? min = null, int? max = null, IntTypeName? type = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Min = min;
            this.Max = max;
            this.Type = type;
        }
    }

    public sealed class FloatDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Float;

        public double? Default { get; }

        public double? Min { get; }

        public double? Max { get; }

        public FloatTypeName? Type { get; }

        public FloatDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null, double? @default = null, double? min = null, double? max = null, FloatTypeName? type = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Min = min;
            this.Max = max;
            this.Type = type;
        }
    }

    public sealed class PathOptions
    {
        public string? Root { get; }

        public string? DefaultPath { get; }

        public string? Extension { get; }

        public bool? IncludeExtension { get; }

        public PathOptions(string? root = null, string? defaultPath = null, string? extension = null, bool? includeExtension = null)
        {
            this.Root = root;
            this.DefaultPath = defaultPath;
            this.Extension = extension;
            this.IncludeExtension = includeExtension;
        }
    }

    public sealed class StringDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.String;

        public string? Default { get; }

        public bool Multiline { get; }

        public bool NotEmpty { get; }

        public bool? LowCardinality { get; }

        public string? Source { get; }

        public PathOptions? Path { get; }

        public string? Syntax { get; }

        public StringDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null, string? @default = null, bool multiline = false, bool notEmpty = false, bool? lowCardinality = null, string? source = null, PathOptions? path = null, string? syntax = null)
            : base(optional, help, editorKey, meta)
        {
            this.Default = @default;
            this.Multiline = multiline;
            this.NotEmpty = notEmpty;
            this.LowCardinality = lowCardinality;
            this.Source = source;
            this.Path = path;
            this.Syntax = syntax;
        }
    }

    public sealed class BinaryDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Binary;

        public BinaryDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class ListDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.List;

        public Descriptor Element { get; }

        public Json.ImmutableJson? Default { get; }

        public ListDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, Descriptor element, Json.ImmutableJson? @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (element == null)
                throw new System.ArgumentNullException(nameof(element));

            this.Element = element;
            this.Default = @default;
        }
    }

    public sealed class DictDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Dict;

        public Descriptor Key { get; }

        public Descriptor Value { get; }

        public IReadOnlyDictionary<string, Descriptor>? Keys { get; }

        public Json.ImmutableJson? Default { get; }

        public DictDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, Descriptor key, Descriptor value, IReadOnlyDictionary<string, Descriptor>? keys = null, Json.ImmutableJson? @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (key == null)
                throw new System.ArgumentNullException(nameof(key));
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            this.Key = key;
            this.Value = value;
            this.Keys = keys;
            this.Default = @default;
        }
    }

    public sealed class EnumDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Enum;

        public string Name { get; }

        public string? Default { get; }

        public EnumDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string name, string? @default = null)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Default = @default;
        }
    }

    public sealed class RecordDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Record;

        public string Name { get; }

        public bool Compact { get; }

        public RecordDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string name, bool compact = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Compact = compact;
        }
    }

    public sealed class UnionDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Union;

        public string Name { get; }

        public bool Compact { get; }

        public UnionDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string name, bool compact = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Compact = compact;
        }
    }

    public sealed class KeyDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Key;

        public string? Category { get; }

        public string? Interface { get; }

        public KeyDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null, string? category = null, string? @interface = null)
            : base(optional, help, editorKey, meta)
        {
            this.Category = category;
            this.Interface = @interface;
        }
    }

    public sealed class LocalizedDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Localized;

        public string Name { get; }

        public bool Multiline { get; }

        public LocalizedDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string name, bool multiline = false)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));

            this.Name = name;
            this.Multiline = multiline;
        }
    }

    public sealed class DateTimeDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Datetime;

        public DateTimeDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class JsonDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Json;

        public JsonDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class CustomDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.Custom;

        public CustomDescriptor(bool optional = false, string? help = null, string? editorKey = null, IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
            : base(optional, help, editorKey, meta)
        {
        }
    }

    public sealed class GenericInstanceDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.GenericInstance;

        public string Prototype { get; }

        public IReadOnlyList<Descriptor> Arguments { get; }

        public GenericInstanceDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string prototype, IReadOnlyList<Descriptor> arguments)
            : base(optional, help, editorKey, meta)
        {
            if (prototype == null)
                throw new System.ArgumentNullException(nameof(prototype));
            if (arguments == null)
                throw new System.ArgumentNullException(nameof(arguments));
            this.Prototype = prototype;
            this.Arguments = arguments;
        }
    }

    public sealed class GenericArgumentDescriptor : Descriptor
    {
        public override DescriptorKind Kind => DescriptorKind.GenericArgument;

        public string Name { get; }

        public GenericArgumentDescriptor(bool optional, string? help, string? editorKey, IReadOnlyDictionary<string, Json.ImmutableJson>? meta, string name)
            : base(optional, help, editorKey, meta)
        {
            if (name == null)
                throw new System.ArgumentNullException(nameof(name));
            this.Name = name;
        }
    }

    public abstract class CustomType
    {
        public abstract CustomTypeKind Kind { get; }

        public IReadOnlyDictionary<string, Json.ImmutableJson>? Meta { get; }

        protected CustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta = null)
        {
            this.Meta = meta;
        }
    }

    public abstract class StructCustomType : CustomType
    {
        public IReadOnlyDictionary<string, Descriptor> Fields { get; }

        public string? Parent { get; }

        public IReadOnlyList<string> Interfaces { get; }

        protected StructCustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta, IReadOnlyDictionary<string, Descriptor> fields, string? parent, IReadOnlyList<string> interfaces)
            : base(meta)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));
            this.Fields = fields;
            this.Parent = parent;
            this.Interfaces = interfaces;
        }
    }

    public sealed class RecordCustomType : StructCustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Record;

        public IReadOnlyList<string>? GenericArguments { get; }

        public string? Group { get; }

        public RecordCustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta, IReadOnlyDictionary<string, Descriptor> fields, string? parent, IReadOnlyList<string> interfaces, IReadOnlyList<string>? genericArguments = null, string? group = null)
            : base(meta, fields, parent, interfaces)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));

            this.GenericArguments = genericArguments;
            this.Group = group;
        }
    }

    public sealed class VariantCustomType : StructCustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Variant;

        public string Tag { get; }

        public IReadOnlyDictionary<string, string> Children { get; }

        public VariantCustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta, IReadOnlyDictionary<string, Descriptor> fields, string? parent, IReadOnlyList<string> interfaces, string tag, IReadOnlyDictionary<string, string> children)
            : base(meta, fields, parent, interfaces)
        {
            if (fields == null)
                throw new System.ArgumentNullException(nameof(fields));

            if (interfaces == null)
                throw new System.ArgumentNullException(nameof(interfaces));
            if (tag == null)
                throw new System.ArgumentNullException(nameof(tag));
            if (children == null)
                throw new System.ArgumentNullException(nameof(children));
            this.Tag = tag;
            this.Children = children;
        }
    }

    public sealed class EnumCustomType : CustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Enum;

        public IReadOnlyList<string> Values { get; }

        public EnumCustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta, IReadOnlyList<string> values)
            : base(meta)
        {
            if (values == null)
                throw new System.ArgumentNullException(nameof(values));
            this.Values = values;
        }
    }

    public sealed class UnionCustomType : CustomType
    {
        public override CustomTypeKind Kind => CustomTypeKind.Union;

        public IReadOnlyDictionary<string, Descriptor?> Clauses { get; }

        public IReadOnlyList<string>? GenericArguments { get; }

        public UnionCustomType(IReadOnlyDictionary<string, Json.ImmutableJson>? meta, IReadOnlyDictionary<string, Descriptor?> clauses, IReadOnlyList<string>? genericArguments = null)
            : base(meta)
        {
            if (clauses == null)
                throw new System.ArgumentNullException(nameof(clauses));

            this.Clauses = clauses;
            this.GenericArguments = genericArguments;
        }
    }

    public sealed class Schema
    {
        public IReadOnlyDictionary<string, CustomType> CustomTypes { get; }

        public string DocumentType { get; }

        public string Version { get; }

        public Schema(IReadOnlyDictionary<string, CustomType> customTypes, string documentType, string version = "1.0")
        {
            if (customTypes == null)
                throw new System.ArgumentNullException(nameof(customTypes));
            if (documentType == null)
                throw new System.ArgumentNullException(nameof(documentType));
            if (version == null)
                throw new System.ArgumentNullException(nameof(version));
            this.CustomTypes = customTypes;
            this.DocumentType = documentType;
            this.Version = version;
        }
    }

    public sealed class DescriptorKindJsonSerializer : Json.Serialization.IJsonSerializer<DescriptorKind>, Json.Serialization.IJsonKeySerializer<DescriptorKind>
    {
        public static readonly DescriptorKindJsonSerializer Instance = new DescriptorKindJsonSerializer();

        public Json.ImmutableJson Serialize(DescriptorKind value)
        {
            return SerializeKey(value);
        }

        public DescriptorKind Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public string SerializeKey(DescriptorKind value)
        {
            return value switch
            {
                DescriptorKind.Bool => "bool",
                DescriptorKind.Int => "int",
                DescriptorKind.Float => "float",
                DescriptorKind.String => "string",
                DescriptorKind.Binary => "binary",
                DescriptorKind.List => "list",
                DescriptorKind.Dict => "dict",
                DescriptorKind.Enum => "enum",
                DescriptorKind.Record => "record",
                DescriptorKind.Union => "union",
                DescriptorKind.Key => "key",
                DescriptorKind.Localized => "localized",
                DescriptorKind.Datetime => "datetime",
                DescriptorKind.Json => "json",
                DescriptorKind.Custom => "custom",
                DescriptorKind.GenericInstance => "generic_instance",
                DescriptorKind.GenericArgument => "generic_argument",
                _ => throw new System.ArgumentOutOfRangeException(nameof(value))
            };
        }

        public DescriptorKind DeserializeKey(string jsonKey)
        {
            return jsonKey switch
            {
                "bool" => DescriptorKind.Bool,
                "int" => DescriptorKind.Int,
                "float" => DescriptorKind.Float,
                "string" => DescriptorKind.String,
                "binary" => DescriptorKind.Binary,
                "list" => DescriptorKind.List,
                "dict" => DescriptorKind.Dict,
                "enum" => DescriptorKind.Enum,
                "record" => DescriptorKind.Record,
                "union" => DescriptorKind.Union,
                "key" => DescriptorKind.Key,
                "localized" => DescriptorKind.Localized,
                "datetime" => DescriptorKind.Datetime,
                "json" => DescriptorKind.Json,
                "custom" => DescriptorKind.Custom,
                "generic_instance" => DescriptorKind.GenericInstance,
                "generic_argument" => DescriptorKind.GenericArgument,
                _ => throw new System.ArgumentOutOfRangeException(nameof(jsonKey))
            };
        }
    }

    public sealed class DescriptorJsonSerializer : Json.Serialization.IJsonSerializer<Descriptor>
    {
        public static readonly DescriptorJsonSerializer Instance = new DescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(Descriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            return value.Kind switch
            {
                DescriptorKind.Bool => BoolDescriptorJsonSerializer.Instance.Serialize((BoolDescriptor)value),
                DescriptorKind.Int => IntDescriptorJsonSerializer.Instance.Serialize((IntDescriptor)value),
                DescriptorKind.Float => FloatDescriptorJsonSerializer.Instance.Serialize((FloatDescriptor)value),
                DescriptorKind.String => StringDescriptorJsonSerializer.Instance.Serialize((StringDescriptor)value),
                DescriptorKind.Binary => BinaryDescriptorJsonSerializer.Instance.Serialize((BinaryDescriptor)value),
                DescriptorKind.List => ListDescriptorJsonSerializer.Instance.Serialize((ListDescriptor)value),
                DescriptorKind.Dict => DictDescriptorJsonSerializer.Instance.Serialize((DictDescriptor)value),
                DescriptorKind.Enum => EnumDescriptorJsonSerializer.Instance.Serialize((EnumDescriptor)value),
                DescriptorKind.Record => RecordDescriptorJsonSerializer.Instance.Serialize((RecordDescriptor)value),
                DescriptorKind.Union => UnionDescriptorJsonSerializer.Instance.Serialize((UnionDescriptor)value),
                DescriptorKind.Key => KeyDescriptorJsonSerializer.Instance.Serialize((KeyDescriptor)value),
                DescriptorKind.Localized => LocalizedDescriptorJsonSerializer.Instance.Serialize((LocalizedDescriptor)value),
                DescriptorKind.Datetime => DateTimeDescriptorJsonSerializer.Instance.Serialize((DateTimeDescriptor)value),
                DescriptorKind.Json => JsonDescriptorJsonSerializer.Instance.Serialize((JsonDescriptor)value),
                DescriptorKind.Custom => CustomDescriptorJsonSerializer.Instance.Serialize((CustomDescriptor)value),
                DescriptorKind.GenericInstance => GenericInstanceDescriptorJsonSerializer.Instance.Serialize((GenericInstanceDescriptor)value),
                DescriptorKind.GenericArgument => GenericArgumentDescriptorJsonSerializer.Instance.Serialize((GenericArgumentDescriptor)value),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }

        public Descriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            DescriptorKind kind = DescriptorKindJsonSerializer.Instance.Deserialize(json["kind"]);
            return kind switch
            {
                DescriptorKind.Bool => BoolDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Int => IntDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Float => FloatDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.String => StringDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Binary => BinaryDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.List => ListDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Dict => DictDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Enum => EnumDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Record => RecordDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Union => UnionDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Key => KeyDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Localized => LocalizedDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Datetime => DateTimeDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Json => JsonDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.Custom => CustomDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.GenericInstance => GenericInstanceDescriptorJsonSerializer.Instance.Deserialize(json),
                DescriptorKind.GenericArgument => GenericArgumentDescriptorJsonSerializer.Instance.Deserialize(json),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }
    }

    public sealed class BoolDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<BoolDescriptor>
    {
        public static readonly BoolDescriptorJsonSerializer Instance = new BoolDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(BoolDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Bool.Serialize(value.Default.Value);
            return json;
        }

        public BoolDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            bool? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Bool.Deserialize(jsonDefault);
            else
                @default = null;
            return new BoolDescriptor(optional, help, editorKey, meta, @default);
        }
    }

    public sealed class IntTypeNameJsonSerializer : Json.Serialization.IJsonSerializer<IntTypeName>, Json.Serialization.IJsonKeySerializer<IntTypeName>
    {
        public static readonly IntTypeNameJsonSerializer Instance = new IntTypeNameJsonSerializer();

        public Json.ImmutableJson Serialize(IntTypeName value)
        {
            return SerializeKey(value);
        }

        public IntTypeName Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public string SerializeKey(IntTypeName value)
        {
            return value switch
            {
                IntTypeName.Int8 => "int8",
                IntTypeName.Uint8 => "uint8",
                IntTypeName.Int16 => "int16",
                IntTypeName.Uint16 => "uint16",
                IntTypeName.Int32 => "int32",
                IntTypeName.Uint32 => "uint32",
                IntTypeName.Int64 => "int64",
                IntTypeName.Uint64 => "uint64",
                _ => throw new System.ArgumentOutOfRangeException(nameof(value))
            };
        }

        public IntTypeName DeserializeKey(string jsonKey)
        {
            return jsonKey switch
            {
                "int8" => IntTypeName.Int8,
                "uint8" => IntTypeName.Uint8,
                "int16" => IntTypeName.Int16,
                "uint16" => IntTypeName.Uint16,
                "int32" => IntTypeName.Int32,
                "uint32" => IntTypeName.Uint32,
                "int64" => IntTypeName.Int64,
                "uint64" => IntTypeName.Uint64,
                _ => throw new System.ArgumentOutOfRangeException(nameof(jsonKey))
            };
        }
    }

    public sealed class IntDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<IntDescriptor>
    {
        public static readonly IntDescriptorJsonSerializer Instance = new IntDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(IntDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Int.Serialize(value.Default.Value);
            if (value.Min.HasValue)
                json["min"] = JsonSerializer.Int.Serialize(value.Min.Value);
            if (value.Max.HasValue)
                json["max"] = JsonSerializer.Int.Serialize(value.Max.Value);
            if (value.Type.HasValue)
                json["type"] = IntTypeNameJsonSerializer.Instance.Serialize(value.Type.Value);
            return json;
        }

        public IntDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            int? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Int.Deserialize(jsonDefault);
            else
                @default = null;
            int? min;
            if (json.AsObject.TryGetValue("min", out var jsonMin) && !jsonMin.IsNull)
                min = JsonSerializer.Int.Deserialize(jsonMin);
            else
                min = null;
            int? max;
            if (json.AsObject.TryGetValue("max", out var jsonMax) && !jsonMax.IsNull)
                max = JsonSerializer.Int.Deserialize(jsonMax);
            else
                max = null;
            IntTypeName? type;
            if (json.AsObject.TryGetValue("type", out var jsonType) && !jsonType.IsNull)
                type = IntTypeNameJsonSerializer.Instance.Deserialize(jsonType);
            else
                type = null;
            return new IntDescriptor(optional, help, editorKey, meta, @default, min, max, type);
        }
    }

    public sealed class FloatTypeNameJsonSerializer : Json.Serialization.IJsonSerializer<FloatTypeName>, Json.Serialization.IJsonKeySerializer<FloatTypeName>
    {
        public static readonly FloatTypeNameJsonSerializer Instance = new FloatTypeNameJsonSerializer();

        public Json.ImmutableJson Serialize(FloatTypeName value)
        {
            return SerializeKey(value);
        }

        public FloatTypeName Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public string SerializeKey(FloatTypeName value)
        {
            return value switch
            {
                FloatTypeName.Float32 => "float32",
                FloatTypeName.Float64 => "float64",
                _ => throw new System.ArgumentOutOfRangeException(nameof(value))
            };
        }

        public FloatTypeName DeserializeKey(string jsonKey)
        {
            return jsonKey switch
            {
                "float32" => FloatTypeName.Float32,
                "float64" => FloatTypeName.Float64,
                _ => throw new System.ArgumentOutOfRangeException(nameof(jsonKey))
            };
        }
    }

    public sealed class FloatDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<FloatDescriptor>
    {
        public static readonly FloatDescriptorJsonSerializer Instance = new FloatDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(FloatDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default.HasValue)
                json["default"] = JsonSerializer.Double.Serialize(value.Default.Value);
            if (value.Min.HasValue)
                json["min"] = JsonSerializer.Double.Serialize(value.Min.Value);
            if (value.Max.HasValue)
                json["max"] = JsonSerializer.Double.Serialize(value.Max.Value);
            if (value.Type.HasValue)
                json["type"] = FloatTypeNameJsonSerializer.Instance.Serialize(value.Type.Value);
            return json;
        }

        public FloatDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            double? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Double.Deserialize(jsonDefault);
            else
                @default = null;
            double? min;
            if (json.AsObject.TryGetValue("min", out var jsonMin) && !jsonMin.IsNull)
                min = JsonSerializer.Double.Deserialize(jsonMin);
            else
                min = null;
            double? max;
            if (json.AsObject.TryGetValue("max", out var jsonMax) && !jsonMax.IsNull)
                max = JsonSerializer.Double.Deserialize(jsonMax);
            else
                max = null;
            FloatTypeName? type;
            if (json.AsObject.TryGetValue("type", out var jsonType) && !jsonType.IsNull)
                type = FloatTypeNameJsonSerializer.Instance.Deserialize(jsonType);
            else
                type = null;
            return new FloatDescriptor(optional, help, editorKey, meta, @default, min, max, type);
        }
    }

    public sealed class PathOptionsJsonSerializer : Json.Serialization.IJsonSerializer<PathOptions>
    {
        public static readonly PathOptionsJsonSerializer Instance = new PathOptionsJsonSerializer();

        public Json.ImmutableJson Serialize(PathOptions value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            if (value.Root != null)
                json["root"] = JsonSerializer.String.Serialize(value.Root);
            if (value.DefaultPath != null)
                json["default_path"] = JsonSerializer.String.Serialize(value.DefaultPath);
            if (value.Extension != null)
                json["extension"] = JsonSerializer.String.Serialize(value.Extension);
            if (value.IncludeExtension.HasValue)
                json["include_extension"] = JsonSerializer.Bool.Serialize(value.IncludeExtension.Value);
            return json;
        }

        public PathOptions Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            string? root;
            if (json.AsObject.TryGetValue("root", out var jsonRoot) && !jsonRoot.IsNull)
                root = JsonSerializer.String.Deserialize(jsonRoot);
            else
                root = null;
            string? defaultPath;
            if (json.AsObject.TryGetValue("default_path", out var jsonDefaultPath) && !jsonDefaultPath.IsNull)
                defaultPath = JsonSerializer.String.Deserialize(jsonDefaultPath);
            else
                defaultPath = null;
            string? extension;
            if (json.AsObject.TryGetValue("extension", out var jsonExtension) && !jsonExtension.IsNull)
                extension = JsonSerializer.String.Deserialize(jsonExtension);
            else
                extension = null;
            bool? includeExtension;
            if (json.AsObject.TryGetValue("include_extension", out var jsonIncludeExtension) && !jsonIncludeExtension.IsNull)
                includeExtension = JsonSerializer.Bool.Deserialize(jsonIncludeExtension);
            else
                includeExtension = null;
            return new PathOptions(root, defaultPath, extension, includeExtension);
        }
    }

    public sealed class StringDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<StringDescriptor>
    {
        public static readonly StringDescriptorJsonSerializer Instance = new StringDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(StringDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Default != null)
                json["default"] = JsonSerializer.String.Serialize(value.Default);
            json["multiline"] = JsonSerializer.Bool.Serialize(value.Multiline);
            json["not_empty"] = JsonSerializer.Bool.Serialize(value.NotEmpty);
            if (value.LowCardinality.HasValue)
                json["low_cardinality"] = JsonSerializer.Bool.Serialize(value.LowCardinality.Value);
            if (value.Source != null)
                json["source"] = JsonSerializer.String.Serialize(value.Source);
            if (value.Path != null)
                json["path"] = PathOptionsJsonSerializer.Instance.Serialize(value.Path);
            if (value.Syntax != null)
                json["syntax"] = JsonSerializer.String.Serialize(value.Syntax);
            return json;
        }

        public StringDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            string? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.String.Deserialize(jsonDefault);
            else
                @default = null;
            bool multiline;
            if (json.AsObject.TryGetValue("multiline", out var jsonMultiline) && !jsonMultiline.IsNull)
                multiline = JsonSerializer.Bool.Deserialize(jsonMultiline);
            else
                multiline = false;
            bool notEmpty;
            if (json.AsObject.TryGetValue("not_empty", out var jsonNotEmpty) && !jsonNotEmpty.IsNull)
                notEmpty = JsonSerializer.Bool.Deserialize(jsonNotEmpty);
            else
                notEmpty = false;
            bool? lowCardinality;
            if (json.AsObject.TryGetValue("low_cardinality", out var jsonLowCardinality) && !jsonLowCardinality.IsNull)
                lowCardinality = JsonSerializer.Bool.Deserialize(jsonLowCardinality);
            else
                lowCardinality = null;
            string? source;
            if (json.AsObject.TryGetValue("source", out var jsonSource) && !jsonSource.IsNull)
                source = JsonSerializer.String.Deserialize(jsonSource);
            else
                source = null;
            PathOptions? path;
            if (json.AsObject.TryGetValue("path", out var jsonPath) && !jsonPath.IsNull)
                path = PathOptionsJsonSerializer.Instance.Deserialize(jsonPath);
            else
                path = null;
            string? syntax;
            if (json.AsObject.TryGetValue("syntax", out var jsonSyntax) && !jsonSyntax.IsNull)
                syntax = JsonSerializer.String.Deserialize(jsonSyntax);
            else
                syntax = null;
            return new StringDescriptor(optional, help, editorKey, meta, @default, multiline, notEmpty, lowCardinality, source, path, syntax);
        }
    }

    public sealed class BinaryDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<BinaryDescriptor>
    {
        public static readonly BinaryDescriptorJsonSerializer Instance = new BinaryDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(BinaryDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public BinaryDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new BinaryDescriptor(optional, help, editorKey, meta);
        }
    }

    public sealed class ListDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<ListDescriptor>
    {
        public static readonly ListDescriptorJsonSerializer Instance = new ListDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(ListDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Element == null)
                throw new System.ArgumentException("Required property Element is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["element"] = DescriptorJsonSerializer.Instance.Serialize(value.Element);
            if (value.Default != null)
                json["default"] = JsonSerializer.Json.Serialize(value.Default);
            return json;
        }

        public ListDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var element = DescriptorJsonSerializer.Instance.Deserialize(json["element"]);
            Json.ImmutableJson? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Json.Deserialize(jsonDefault);
            else
                @default = null;
            return new ListDescriptor(optional, help, editorKey, meta, element, @default);
        }
    }

    public sealed class DictDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<DictDescriptor>
    {
        public static readonly DictDescriptorJsonSerializer Instance = new DictDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(DictDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Key == null)
                throw new System.ArgumentException("Required property Key is null", nameof(value));
            if (value.Value == null)
                throw new System.ArgumentException("Required property Value is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["key"] = DescriptorJsonSerializer.Instance.Serialize(value.Key);
            json["value"] = DescriptorJsonSerializer.Instance.Serialize(value.Value);
            if (value.Keys != null)
                json["keys"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Serialize(value.Keys);
            if (value.Default != null)
                json["default"] = JsonSerializer.Json.Serialize(value.Default);
            return json;
        }

        public DictDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var key = DescriptorJsonSerializer.Instance.Deserialize(json["key"]);
            var value = DescriptorJsonSerializer.Instance.Deserialize(json["value"]);
            IReadOnlyDictionary<string, Descriptor>? keys;
            if (json.AsObject.TryGetValue("keys", out var jsonKeys) && !jsonKeys.IsNull)
                keys = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Deserialize(jsonKeys);
            else
                keys = null;
            Json.ImmutableJson? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.Json.Deserialize(jsonDefault);
            else
                @default = null;
            return new DictDescriptor(optional, help, editorKey, meta, key, value, keys, @default);
        }
    }

    public sealed class EnumDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<EnumDescriptor>
    {
        public static readonly EnumDescriptorJsonSerializer Instance = new EnumDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(EnumDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            if (value.Default != null)
                json["default"] = JsonSerializer.String.Serialize(value.Default);
            return json;
        }

        public EnumDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            string? @default;
            if (json.AsObject.TryGetValue("default", out var jsonDefault) && !jsonDefault.IsNull)
                @default = JsonSerializer.String.Deserialize(jsonDefault);
            else
                @default = null;
            return new EnumDescriptor(optional, help, editorKey, meta, name, @default);
        }
    }

    public sealed class RecordDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<RecordDescriptor>
    {
        public static readonly RecordDescriptorJsonSerializer Instance = new RecordDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(RecordDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["compact"] = JsonSerializer.Bool.Serialize(value.Compact);
            return json;
        }

        public RecordDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool compact;
            if (json.AsObject.TryGetValue("compact", out var jsonCompact) && !jsonCompact.IsNull)
                compact = JsonSerializer.Bool.Deserialize(jsonCompact);
            else
                compact = false;
            return new RecordDescriptor(optional, help, editorKey, meta, name, compact);
        }
    }

    public sealed class UnionDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<UnionDescriptor>
    {
        public static readonly UnionDescriptorJsonSerializer Instance = new UnionDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(UnionDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["compact"] = JsonSerializer.Bool.Serialize(value.Compact);
            return json;
        }

        public UnionDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool compact;
            if (json.AsObject.TryGetValue("compact", out var jsonCompact) && !jsonCompact.IsNull)
                compact = JsonSerializer.Bool.Deserialize(jsonCompact);
            else
                compact = false;
            return new UnionDescriptor(optional, help, editorKey, meta, name, compact);
        }
    }

    public sealed class KeyDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<KeyDescriptor>
    {
        public static readonly KeyDescriptorJsonSerializer Instance = new KeyDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(KeyDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            if (value.Category != null)
                json["category"] = JsonSerializer.String.Serialize(value.Category);
            if (value.Interface != null)
                json["interface"] = JsonSerializer.String.Serialize(value.Interface);
            return json;
        }

        public KeyDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            string? category;
            if (json.AsObject.TryGetValue("category", out var jsonCategory) && !jsonCategory.IsNull)
                category = JsonSerializer.String.Deserialize(jsonCategory);
            else
                category = null;
            string? @interface;
            if (json.AsObject.TryGetValue("interface", out var jsonInterface) && !jsonInterface.IsNull)
                @interface = JsonSerializer.String.Deserialize(jsonInterface);
            else
                @interface = null;
            return new KeyDescriptor(optional, help, editorKey, meta, category, @interface);
        }
    }

    public sealed class LocalizedDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<LocalizedDescriptor>
    {
        public static readonly LocalizedDescriptorJsonSerializer Instance = new LocalizedDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(LocalizedDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            json["multiline"] = JsonSerializer.Bool.Serialize(value.Multiline);
            return json;
        }

        public LocalizedDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            bool multiline;
            if (json.AsObject.TryGetValue("multiline", out var jsonMultiline) && !jsonMultiline.IsNull)
                multiline = JsonSerializer.Bool.Deserialize(jsonMultiline);
            else
                multiline = false;
            return new LocalizedDescriptor(optional, help, editorKey, meta, name, multiline);
        }
    }

    public sealed class DateTimeDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<DateTimeDescriptor>
    {
        public static readonly DateTimeDescriptorJsonSerializer Instance = new DateTimeDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(DateTimeDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public DateTimeDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new DateTimeDescriptor(optional, help, editorKey, meta);
        }
    }

    public sealed class JsonDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<JsonDescriptor>
    {
        public static readonly JsonDescriptorJsonSerializer Instance = new JsonDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(JsonDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public JsonDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new JsonDescriptor(optional, help, editorKey, meta);
        }
    }

    public sealed class CustomDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<CustomDescriptor>
    {
        public static readonly CustomDescriptorJsonSerializer Instance = new CustomDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(CustomDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            return json;
        }

        public CustomDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            return new CustomDescriptor(optional, help, editorKey, meta);
        }
    }

    public sealed class GenericInstanceDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<GenericInstanceDescriptor>
    {
        public static readonly GenericInstanceDescriptorJsonSerializer Instance = new GenericInstanceDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(GenericInstanceDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Prototype == null)
                throw new System.ArgumentException("Required property Prototype is null", nameof(value));
            if (value.Arguments == null)
                throw new System.ArgumentException("Required property Arguments is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["prototype"] = JsonSerializer.String.Serialize(value.Prototype);
            json["arguments"] = JsonSerializer.ReadOnlyList(DescriptorJsonSerializer.Instance).Serialize(value.Arguments);
            return json;
        }

        public GenericInstanceDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var prototype = JsonSerializer.String.Deserialize(json["prototype"]);
            var arguments = JsonSerializer.ReadOnlyList(DescriptorJsonSerializer.Instance).Deserialize(json["arguments"]);
            return new GenericInstanceDescriptor(optional, help, editorKey, meta, prototype, arguments);
        }
    }

    public sealed class GenericArgumentDescriptorJsonSerializer : Json.Serialization.IJsonSerializer<GenericArgumentDescriptor>
    {
        public static readonly GenericArgumentDescriptorJsonSerializer Instance = new GenericArgumentDescriptorJsonSerializer();

        public Json.ImmutableJson Serialize(GenericArgumentDescriptor value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Name == null)
                throw new System.ArgumentException("Required property Name is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = DescriptorKindJsonSerializer.Instance.Serialize(value.Kind);
            json["optional"] = JsonSerializer.Bool.Serialize(value.Optional);
            if (value.Help != null)
                json["help"] = JsonSerializer.String.Serialize(value.Help);
            if (value.EditorKey != null)
                json["editor_key"] = JsonSerializer.String.Serialize(value.EditorKey);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["name"] = JsonSerializer.String.Serialize(value.Name);
            return json;
        }

        public GenericArgumentDescriptor Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            bool optional;
            if (json.AsObject.TryGetValue("optional", out var jsonOptional) && !jsonOptional.IsNull)
                optional = JsonSerializer.Bool.Deserialize(jsonOptional);
            else
                optional = false;
            string? help;
            if (json.AsObject.TryGetValue("help", out var jsonHelp) && !jsonHelp.IsNull)
                help = JsonSerializer.String.Deserialize(jsonHelp);
            else
                help = null;
            string? editorKey;
            if (json.AsObject.TryGetValue("editor_key", out var jsonEditorKey) && !jsonEditorKey.IsNull)
                editorKey = JsonSerializer.String.Deserialize(jsonEditorKey);
            else
                editorKey = null;
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var name = JsonSerializer.String.Deserialize(json["name"]);
            return new GenericArgumentDescriptor(optional, help, editorKey, meta, name);
        }
    }

    public sealed class CustomTypeKindJsonSerializer : Json.Serialization.IJsonSerializer<CustomTypeKind>, Json.Serialization.IJsonKeySerializer<CustomTypeKind>
    {
        public static readonly CustomTypeKindJsonSerializer Instance = new CustomTypeKindJsonSerializer();

        public Json.ImmutableJson Serialize(CustomTypeKind value)
        {
            return SerializeKey(value);
        }

        public CustomTypeKind Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            return DeserializeKey(json.AsString);
        }

        public string SerializeKey(CustomTypeKind value)
        {
            return value switch
            {
                CustomTypeKind.Record => "record",
                CustomTypeKind.Variant => "variant",
                CustomTypeKind.Enum => "enum",
                CustomTypeKind.Union => "union",
                _ => throw new System.ArgumentOutOfRangeException(nameof(value))
            };
        }

        public CustomTypeKind DeserializeKey(string jsonKey)
        {
            return jsonKey switch
            {
                "record" => CustomTypeKind.Record,
                "variant" => CustomTypeKind.Variant,
                "enum" => CustomTypeKind.Enum,
                "union" => CustomTypeKind.Union,
                _ => throw new System.ArgumentOutOfRangeException(nameof(jsonKey))
            };
        }
    }

    public sealed class CustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<CustomType>
    {
        public static readonly CustomTypeJsonSerializer Instance = new CustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(CustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            return value.Kind switch
            {
                CustomTypeKind.Record => RecordCustomTypeJsonSerializer.Instance.Serialize((RecordCustomType)value),
                CustomTypeKind.Variant => VariantCustomTypeJsonSerializer.Instance.Serialize((VariantCustomType)value),
                CustomTypeKind.Enum => EnumCustomTypeJsonSerializer.Instance.Serialize((EnumCustomType)value),
                CustomTypeKind.Union => UnionCustomTypeJsonSerializer.Instance.Serialize((UnionCustomType)value),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }

        public CustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            CustomTypeKind kind = CustomTypeKindJsonSerializer.Instance.Deserialize(json["kind"]);
            return kind switch
            {
                CustomTypeKind.Record => RecordCustomTypeJsonSerializer.Instance.Deserialize(json),
                CustomTypeKind.Variant => VariantCustomTypeJsonSerializer.Instance.Deserialize(json),
                CustomTypeKind.Enum => EnumCustomTypeJsonSerializer.Instance.Deserialize(json),
                CustomTypeKind.Union => UnionCustomTypeJsonSerializer.Instance.Deserialize(json),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }
    }

    public sealed class StructCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<StructCustomType>
    {
        public static readonly StructCustomTypeJsonSerializer Instance = new StructCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(StructCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            return value.Kind switch
            {
                CustomTypeKind.Record => RecordCustomTypeJsonSerializer.Instance.Serialize((RecordCustomType)value),
                CustomTypeKind.Variant => VariantCustomTypeJsonSerializer.Instance.Serialize((VariantCustomType)value),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }

        public StructCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            CustomTypeKind kind = CustomTypeKindJsonSerializer.Instance.Deserialize(json["kind"]);
            return kind switch
            {
                CustomTypeKind.Record => RecordCustomTypeJsonSerializer.Instance.Deserialize(json),
                CustomTypeKind.Variant => VariantCustomTypeJsonSerializer.Instance.Deserialize(json),
                _ => throw new System.ArgumentException("Invalid variant tag")
            };
        }
    }

    public sealed class RecordCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<RecordCustomType>
    {
        public static readonly RecordCustomTypeJsonSerializer Instance = new RecordCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(RecordCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Fields == null)
                throw new System.ArgumentException("Required property Fields is null", nameof(value));

            if (value.Interfaces == null)
                throw new System.ArgumentException("Required property Interfaces is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["fields"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Serialize(value.Fields);
            if (value.Parent != null)
                json["parent"] = JsonSerializer.String.Serialize(value.Parent);
            json["interfaces"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Interfaces);
            if (value.GenericArguments != null)
                json["generic_arguments"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.GenericArguments);
            if (value.Group != null)
                json["group"] = JsonSerializer.String.Serialize(value.Group);
            return json;
        }

        public RecordCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var fields = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Deserialize(json["fields"]);
            string? parent;
            if (json.AsObject.TryGetValue("parent", out var jsonParent) && !jsonParent.IsNull)
                parent = JsonSerializer.String.Deserialize(jsonParent);
            else
                parent = null;
            var interfaces = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["interfaces"]);
            IReadOnlyList<string>? genericArguments;
            if (json.AsObject.TryGetValue("generic_arguments", out var jsonGenericArguments) && !jsonGenericArguments.IsNull)
                genericArguments = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(jsonGenericArguments);
            else
                genericArguments = null;
            string? group;
            if (json.AsObject.TryGetValue("group", out var jsonGroup) && !jsonGroup.IsNull)
                group = JsonSerializer.String.Deserialize(jsonGroup);
            else
                group = null;
            return new RecordCustomType(meta, fields, parent, interfaces, genericArguments, group);
        }
    }

    public sealed class VariantCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<VariantCustomType>
    {
        public static readonly VariantCustomTypeJsonSerializer Instance = new VariantCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(VariantCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Fields == null)
                throw new System.ArgumentException("Required property Fields is null", nameof(value));

            if (value.Interfaces == null)
                throw new System.ArgumentException("Required property Interfaces is null", nameof(value));
            if (value.Tag == null)
                throw new System.ArgumentException("Required property Tag is null", nameof(value));
            if (value.Children == null)
                throw new System.ArgumentException("Required property Children is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["fields"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Serialize(value.Fields);
            if (value.Parent != null)
                json["parent"] = JsonSerializer.String.Serialize(value.Parent);
            json["interfaces"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Interfaces);
            json["tag"] = JsonSerializer.String.Serialize(value.Tag);
            json["children"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.String).Serialize(value.Children);
            return json;
        }

        public VariantCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var fields = JsonSerializer.ReadOnlyDict(JsonSerializer.String, DescriptorJsonSerializer.Instance).Deserialize(json["fields"]);
            string? parent;
            if (json.AsObject.TryGetValue("parent", out var jsonParent) && !jsonParent.IsNull)
                parent = JsonSerializer.String.Deserialize(jsonParent);
            else
                parent = null;
            var interfaces = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["interfaces"]);
            var tag = JsonSerializer.String.Deserialize(json["tag"]);
            var children = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.String).Deserialize(json["children"]);
            return new VariantCustomType(meta, fields, parent, interfaces, tag, children);
        }
    }

    public sealed class EnumCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<EnumCustomType>
    {
        public static readonly EnumCustomTypeJsonSerializer Instance = new EnumCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(EnumCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Values == null)
                throw new System.ArgumentException("Required property Values is null", nameof(value));
            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["values"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.Values);
            return json;
        }

        public EnumCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var values = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(json["values"]);
            return new EnumCustomType(meta, values);
        }
    }

    public sealed class UnionCustomTypeJsonSerializer : Json.Serialization.IJsonSerializer<UnionCustomType>
    {
        public static readonly UnionCustomTypeJsonSerializer Instance = new UnionCustomTypeJsonSerializer();

        public Json.ImmutableJson Serialize(UnionCustomType value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));

            if (value.Clauses == null)
                throw new System.ArgumentException("Required property Clauses is null", nameof(value));

            var json = new Json.JsonObject();
            json["kind"] = CustomTypeKindJsonSerializer.Instance.Serialize(value.Kind);
            if (value.Meta != null)
                json["meta"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Serialize(value.Meta);
            json["clauses"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Optional(DescriptorJsonSerializer.Instance)).Serialize(value.Clauses);
            if (value.GenericArguments != null)
                json["generic_arguments"] = JsonSerializer.ReadOnlyList(JsonSerializer.String).Serialize(value.GenericArguments);
            return json;
        }

        public UnionCustomType Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            IReadOnlyDictionary<string, Json.ImmutableJson>? meta;
            if (json.AsObject.TryGetValue("meta", out var jsonMeta) && !jsonMeta.IsNull)
                meta = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Json).Deserialize(jsonMeta);
            else
                meta = null;
            var clauses = JsonSerializer.ReadOnlyDict(JsonSerializer.String, JsonSerializer.Optional(DescriptorJsonSerializer.Instance)).Deserialize(json["clauses"]);
            IReadOnlyList<string>? genericArguments;
            if (json.AsObject.TryGetValue("generic_arguments", out var jsonGenericArguments) && !jsonGenericArguments.IsNull)
                genericArguments = JsonSerializer.ReadOnlyList(JsonSerializer.String).Deserialize(jsonGenericArguments);
            else
                genericArguments = null;
            return new UnionCustomType(meta, clauses, genericArguments);
        }
    }

    public sealed class SchemaJsonSerializer : Json.Serialization.IJsonSerializer<Schema>
    {
        public static readonly SchemaJsonSerializer Instance = new SchemaJsonSerializer();

        public Json.ImmutableJson Serialize(Schema value)
        {
            if (value == null)
                throw new System.ArgumentNullException(nameof(value));
            if (value.CustomTypes == null)
                throw new System.ArgumentException("Required property CustomTypes is null", nameof(value));
            if (value.DocumentType == null)
                throw new System.ArgumentException("Required property DocumentType is null", nameof(value));
            if (value.Version == null)
                throw new System.ArgumentException("Required property Version is null", nameof(value));
            return new Json.JsonObject
            {
                ["custom_types"] = JsonSerializer.ReadOnlyDict(JsonSerializer.String, CustomTypeJsonSerializer.Instance).Serialize(value.CustomTypes),
                ["document_type"] = JsonSerializer.String.Serialize(value.DocumentType),
                ["version"] = JsonSerializer.String.Serialize(value.Version)
            };
        }

        public Schema Deserialize(Json.ImmutableJson json)
        {
            if (json == null)
                throw new System.ArgumentNullException(nameof(json));
            var customTypes = JsonSerializer.ReadOnlyDict(JsonSerializer.String, CustomTypeJsonSerializer.Instance).Deserialize(json["custom_types"]);
            var documentType = JsonSerializer.String.Deserialize(json["document_type"]);
            string version;
            if (json.AsObject.TryGetValue("version", out var jsonVersion) && !jsonVersion.IsNull)
                version = JsonSerializer.String.Deserialize(jsonVersion);
            else
                version = "1.0";
            return new Schema(customTypes, documentType, version);
        }
    }
}
